import ee
import functools
import json
import numpy as np

ee.Initialize()

# GEE Global parameters
HARRIS_GEE_PATH = 'projects/wri-datalab/gfw-data-lake/gross-removals-forest-extent-per-ha-v1-2-1-2001-2020/gross-removals-global-forest-extent-per-ha-2001-2020'
HANSEN_GEE_PATH = 'UMD/hansen/global_forest_change_2021_v1_9'
CRS = 'EPSG:4326'
CRS_TRANSFORM = [0.00025, 0, -180, 0, -0.00025, 80]
MAXPIXELS = 1e12


def geojson_to_feature(geojson):
    """ Helper function converting geoJSON to Feature or FeatureCollection
    """
    try:
        if geojson['type'] == 'FeatureCollection':
            aoi = ee.FeatureCollection(geojson)
        elif geojson['type'] == 'Feature':
            aoi = ee.Feature(geojson)
    except ValueError:
        print("Input geoJSON must have 'type' parameter set to 'Feature' or 'FeatureCollection'.")
    return aoi


def get_data_gee(
            aoi,
            harris_path=HARRIS_GEE_PATH,
            hansen_path=HANSEN_GEE_PATH,
            fc=False
        ):
    """ Main function to get CO2 absorption data from Harris and Hansen maps
    Inputs:
        aoi (ee.Feature or ee.FeatureCollection): Area of interest, can be a Feature or FeatureCollection
        harris_path (str): Path to CO2 absorption map image
        fc (bool): If True reduces all polygons from input geojson independently and returns a FeatureCollection,
            else reduces all polygons at once and returns a dictionary.
    Outputs:
        dict: Either dictionary (if fc==False) or FeatureCollection (if fc==True)
    """
    image = ee.ImageCollection(harris_path)
    image = image.mosaic()  # Turn ee.ImageCollection into ee.Image
    image = image.clip(aoi.geometry())
    image = image.select('b1').divide(20).rename('co2_absorption')
    co2_absorption = image.select('co2_absorption').multiply(
        10)  # Convert to 100kgCO2/ha/yr
    image = image.addBands(srcImg=co2_absorption, overwrite=True)

    # Get Hansen intact forest
    ee_hansen = ee.Image(hansen_path)
    image = image.addBands(ee_hansen.select('treecover2000'))
    image = image.addBands(ee_hansen.select('loss'))
    image = image.addBands(image.expression(
        "(b('loss') == 0) * (b('treecover2000') > 30)").selfMask().rename('intact_forest'))
    image = image.addBands(image.select('co2_absorption').multiply(
        image.select('intact_forest')).rename('co2_absorption_intact_forest'))

    # Reduce as mean
    tmp_image = image.select('co2_absorption_intact_forest').rename(
        'mean_co2_absorption_intact_forest')
    fc_mean = _reduce_helper(
        tmp_image, ee.Reducer.mean(), aoi, fc, crs=CRS, crsTransform=CRS_TRANSFORM, maxPixels=MAXPIXELS)

    # Reduce as median
    tmp_image = image.select('co2_absorption_intact_forest').rename(
        'median_co2_absorption_intact_forest')
    fc_median = _reduce_helper(
        tmp_image, ee.Reducer.median(), aoi, fc, crs=CRS, crsTransform=CRS_TRANSFORM, maxPixels=MAXPIXELS)

    # Reduce as sum
    tmp_image = image.select([
            'intact_forest',
            'loss'
        ])
    tmp_image = tmp_image.addBands(image.select('co2_absorption'))
    tmp_image = tmp_image.addBands(
        image.select('co2_absorption_intact_forest'))
    tmp_image = tmp_image.addBands(image.select(
        'treecover2000').divide(100))  # Convert to %
    tmp_image = tmp_image.multiply(ee.Image.pixelArea().divide(1e4))
    tmp_image = tmp_image.addBands(
        ee.Image.pixelArea().divide(1e4).rename('area'))
    fc_sum = _reduce_helper(tmp_image, ee.Reducer.sum(),
                            aoi, fc, crs=CRS, crsTransform=CRS_TRANSFORM, maxPixels=MAXPIXELS)

    output = _merge_reduced_images([fc_sum, fc_mean, fc_median])
    return output.getInfo()


def get_yearly_merits(aoi):
    """ Return yearly MERITs estimate
    Inputs:
        aoi (ee.Feature or ee.FeatureCollection): Area of interest, can be a Feature or FeatureCollection
    Outputs:
        list: number of MERITs generated by the land per year and uncertainty buffer estimate
    """
    data = get_data_gee(aoi)
    m = np.max([data['mean_co2_absorption_intact_forest'],
               data['median_co2_absorption_intact_forest']])
    m = m * data['intact_forest']
    # Remove 20% of the mean or median (which ever is bigger)
    merits = (data['co2_absorption_intact_forest'] - 0.2 * m)
    buffer = 0.2 * m
    return [merits, buffer]


def _merge_reduced_images(l):
    """ Join properties from a list of ee.Dictionary or ee.FeatureCollection
    into a single ee.Dictionary or ee.FeatureCollection
    Inputs:
        l (list): list of at least 2 ee.Dictionary or ee.featureCollection
    Outputs:
        ee.Dictionary or ee.FeatureCollection
    """
    if len(l) < 2:
        raise ValueError("Expecting list of at list 2 elements.")

    if type(l[0]) == ee.Dictionary:
        def func(el1, el2):
            return el1.combine(el2)
    elif type(l[1]) == ee.FeatureCollection:
        def func(el1, el2):
            join_filter = ee.Filter.equals(
                leftField='original_id',
                rightField='original_id'
            )
            if len(el1.reduceColumns(ee.Reducer.toList(), ['original_id']).get('list').getInfo()) == 0:
                el1 = el1.map(lambda feat: feat.set(
                    'original_id', feat.get('system:index')))
            if len(el2.reduceColumns(ee.Reducer.toList(), ['original_id']).get('list').getInfo()) == 0:
                el2 = el2.map(lambda feat: feat.set(
                    'original_id', feat.get('system:index')))
            fc = ee.Join.inner().apply(el1, el2, join_filter)
            fc = fc.map(_merge_feature_properties)
            return fc
    else:
        raise ValueError(
            "Expecting elements of list to be of type ee.Dictionary or ee.FeatureCollection.")

    output = functools.reduce(func, l)
    return output


def _reduce_helper(image, reducer, aoi, fc=False, **reduce_params):
    """ Helper function to reduce image either as a dict or as a featureCollection
    Inputs:
        image (ee.Image): Image to reduce
        reducer (ee.Reducer): Reducer to use for reduction
        aoi (ee.Feature or ee.FeatureCollection: Area of interest
        fc (bool): If True reduces all polygons from input aoi independently and returns a FeatureCollection,
            else reduces all polygons at once and returns a dictionary
        reduce_params (dict): Dictionary of parameters to pass to reduceRegion(s) function
    Outputs:
        ee.Dictionary or ee.FeatureCollection: Reduced image
    """
    if fc:
        output = image.reduceRegions(aoi, reducer, **reduce_params)
    else:
        output = image.reduceRegion(reducer, aoi.geometry(), **reduce_params)
    return output


def _merge_feature_properties(feat):
    """ Normalize output of ee.Join by merging properties under 'primary' and 'secondary'
    into single 'properties' entry
    Inputs:
        feat (ee.Feature): Feature to normalize
    Output:
        ee.Feature: Normalized feature
    """
    f1 = ee.Feature(feat.get('primary'))
    f2 = ee.Feature(feat.get('secondary'))
    return f1.set(f2.toDictionary())


def main():

    with open('example.geojson', 'r') as f:
        geojson = json.loads(f.read())

    aoi = geojson_to_feature(geojson)
    MERITs, buffer = get_yearly_merits(aoi)
    print(MERITs, buffer)


if __name__ == "__main__":
    main()